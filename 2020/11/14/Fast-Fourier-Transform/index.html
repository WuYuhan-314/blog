<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuhanwu314.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Introduction This article is intended to introduce 1-dimensional \(2^n\)-point FFT algorithm. Firstly, the definition of discrete fourier transform will be introduced. Then, we will study the easiest">
<meta property="og:type" content="article">
<meta property="og:title" content="Fast Fourier Transform">
<meta property="og:url" content="https://yuhanwu314.github.io/blog/2020/11/14/Fast-Fourier-Transform/index.html">
<meta property="og:site_name" content="Yuhan Wu&#39;s personal website">
<meta property="og:description" content="Introduction This article is intended to introduce 1-dimensional \(2^n\)-point FFT algorithm. Firstly, the definition of discrete fourier transform will be introduced. Then, we will study the easiest">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-14T06:19:36.000Z">
<meta property="article:modified_time" content="2020-11-14T06:21:41.489Z">
<meta property="article:author" content="Yuhan Wu">
<meta property="article:tag" content="FFT">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yuhanwu314.github.io/blog/2020/11/14/Fast-Fourier-Transform/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Fast Fourier Transform | Yuhan Wu's personal website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yuhan Wu's personal website</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yuhanwu314.github.io/blog/2020/11/14/Fast-Fourier-Transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/YuhanWu314/Picture/main/touxiang.gif">
      <meta itemprop="name" content="Yuhan Wu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuhan Wu's personal website">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Fast Fourier Transform
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-14 14:19:36 / Modified: 14:21:41" itemprop="dateCreated datePublished" datetime="2020-11-14T14:19:36+08:00">2020-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/lecture-notes/" itemprop="url" rel="index"><span itemprop="name">lecture notes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="introduction">Introduction</h1>
<p>This article is intended to introduce 1-dimensional <span class="math inline">\(2^n\)</span>-point FFT algorithm. Firstly, the definition of discrete fourier transform will be introduced. Then, we will study the easiest fast Fourier transform: Radix-2 DIT(decimation in time)-FFT algorithm. We will start from some simple examples: 2-point, 4-point and 8-point FFT. Then the <span class="math inline">\(2^n\)</span>-FFT will be discussed.</p>
<a id="more"></a>
<h1 id="discrete-fourier-transformation">Discrete Fourier Transformation</h1>
<p>Suppose <span class="math inline">\(\{x(n)\}\)</span> is a N-point array of data, where <span class="math inline">\(n=0,1\cdots,N-1\)</span>, and <span class="math inline">\(\{X^F(k)\}\)</span> is discrete fourier transformation of <span class="math inline">\(\{x(n)\}\)</span>. The definition of <span class="math inline">\(X^F(k)\)</span> is <span class="math display">\[X^F(k)=\sum_{n=0}^{N-1}x(n) \exp(\frac{-2\pi k j}{N}\cdot n)\]</span> where <span class="math inline">\(j\)</span> represents the imaginary number and <span class="math inline">\(k=0,1,\cdots,N-1\)</span>. Here will introduce a notation <span class="math inline">\(W_N\)</span> <span class="math display">\[W_N=\exp(\frac{-2\pi j}{N})\]</span> Therefore, <span class="math display">\[\exp(\frac{-2\pi k j}{N}\cdot n)= W_N^{kn}\]</span> and <span class="math display">\[X^F(k)=\sum_{n=0}^{n-1}W_N^{kn}x(n)\]</span></p>
<p>For example, if N=4, 4-point DFT can be written in matrix form: <span class="math display">\[\begin{pmatrix}
            X^F(0)\\ X^F(1) \\ X^F(2) \\ X^F(3)
        \end{pmatrix}=
        \begin{pmatrix}
            W^{00}_4&amp;W^{01}_4  &amp;W^{02}_4  &amp;W^{03}_4  \\
            W^{10}_4&amp;W^{11}_4  &amp;W^{12}_4  &amp;W^{13}_4  \\
            W^{20}_4&amp;W^{21}_4  &amp;W^{22}_4  &amp;W^{23}_4  \\
            W^{30}_4&amp;W^{31}_4  &amp;W^{32}_4  &amp;W^{33}_4 
        \end{pmatrix}
        \begin{pmatrix}
            x(0)\\ x(1)\\ x(2)\\ x(3)
        \end{pmatrix}\]</span></p>
<h1 id="main-algorithm">Main algorithm</h1>
<p>From the matrix representation of N-DFT, we can calculate its computational complexity is <span class="math inline">\(N^2\)</span>. Our main motivation is to decompose N-point sequence into two <span class="math inline">\(\frac{N}{2}\)</span>-point sequences. Therefore, we can reduce the computational complexity to <span class="math inline">\(2\cdot\frac{N^2}{4}+cN\)</span>, where c is a constant. Furthermore, we can apply this repeatedly. The computational complexity will be reduced to <span class="math inline">\(O(N \log N)\)</span> <span class="math display">\[\begin{aligned}
        X^F(k)&amp;=\sum_{n=0}^{N-1}x(n)W_N^{kn}\\
        &amp;=\sum_{n=\text{even integer}}x(n)W_N^{kn}+\sum_{n=\text{odd integer}}x(n)W_N^{kn}\\
        &amp;=\sum_{r=0}^{\frac{N}{2}-1}x(2r)W_N^{2rk}+\sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_N^{(2r+1)k}\\
        &amp;=\sum_{r=0}^{\frac{N}{2}-1}x(2r)(W_N^2)^{rk}+W_N^k\sum_{r=0}^{\frac{N}{2}-1}x(2r+1)(W_N^2)^{rk}\\
    \end{aligned}\]</span> Noticed that, <span class="math display">\[W_N^2=\exp(\frac{-2\pi j \cdot 2}{N})=\exp(\frac{-2\pi j}{\frac{N}{2}})=W_{\frac{N}{2}}\]</span></p>
<p>Therefore <span class="math display">\[X^F(k)=\sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{rk}+W_N^k\sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{rk}\]</span></p>
<p>Observe that <span class="math display">\[G^F(k)=\sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{rk}\]</span> and <span class="math display">\[H^(k)=\sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{rk}\]</span> are two <span class="math inline">\(\frac{N}{2}\)</span>-point DFT. Therefore, we can conclude <span class="math display">\[X^F=G^F(k)+W_N^kH^F(k)\]</span> for <span class="math inline">\(k=0,1,\cdots,\frac{N}{2}-1\)</span> When <span class="math inline">\(k\geq \frac{N}{2}\)</span>, <span class="math display">\[\begin{split}
            X^F(k+\frac{N}{2})&amp;=\sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{r(k+\frac{N}{2})}+W_N^(k+\frac{N}{2})\sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{r(k+\frac{N}{2})}\\
            &amp;=W_{\frac{N}{2}}^{\frac{N}{2}}\{\sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{rk}+W_N^{(k+\frac{N}{2})}\sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{rk}\}\\
        \end{split}\]</span> It is easy to verify that <span class="math display">\[W_{\frac{N}{2}}^{\frac{N}{2}}=\exp(\frac{-2\pi j \frac{N}{2}}{\frac{N}{2}})=1 \quad W_{N}^{\frac{N}{2}}=\exp(\frac{-2\pi j \frac{N}{2}}{N})=-1\\
\]</span> Therefore <span class="math display">\[\begin{split}
            X^F(k+\frac{N}{2})&amp;=\{\sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{rk}-W_N^{k}\sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{rk}\}\\
            &amp;=G^F(k)-W_N^kH^F(k)
        \end{split}\]</span></p>
<h1 id="detailed-examples">Detailed examples</h1>
<p>Let's start from the easiest situation 2-point DFT.</p>
<h2 id="point-dft">2-point DFT</h2>
<p>N=2, <span class="math inline">\(W_2=\exp(\frac{-2\pi j}{2})=-1\)</span>, we write it in matrix form: <span class="math display">\[\begin{pmatrix}
                X^F(0)\\ X^F(1)
            \end{pmatrix}=
            \begin{pmatrix}
                W_{2}^{00}&amp;W_{2}^{01}  \\
                W_{2}^{10}&amp;W_{2}^{11} 
            \end{pmatrix}
            \begin{pmatrix}
                x(0)\\x(1)
            \end{pmatrix}=
            \begin{pmatrix}
                1&amp; 1 \\
                1&amp; -1
            \end{pmatrix}\begin{pmatrix}
                x(0)\\x(1)
            \end{pmatrix}\]</span> In other words <span class="math inline">\(X^F(0)=x(0)+x(1)\)</span> and <span class="math inline">\(X^F(1)=x(0)-x(1)\)</span>.</p>
<h2 id="point-fft">4-point FFT</h2>
<p>As we have proved, the 4-point DFT can be expressed as the sum of two 2-point DFT, <span class="math display">\[X^F(k)=A_1(k)+W_4^kA_2(k)\]</span> where <span class="math inline">\(A_1(k)=DFT\{x(0),x(2)\}(k)\)</span> and <span class="math inline">\(A_2(k)=DFT\{x(1),x(3)\}\)</span>, explicitly <span class="math display">\[\begin{pmatrix}
                A_1(0)\\A_1(1)
            \end{pmatrix}=
            \begin{pmatrix}
                1&amp;  1\\
               1 &amp; -1
            \end{pmatrix}\begin{pmatrix}
                x(0)\\x(2)
            \end{pmatrix}\]</span> and <span class="math display">\[\begin{pmatrix}
                A_2(0)\\A_2(1)
            \end{pmatrix}=
            \begin{pmatrix}
                1&amp;  1\\
               1 &amp; -1
            \end{pmatrix}\begin{pmatrix}
                x(1)\\x(3)
            \end{pmatrix}\]</span> The 4-point DFT can be expressed as <span class="math display">\[\begin{pmatrix}
                X^F(0)\\ X^F(1)\\X^F(2)\\ X^F(3)
            \end{pmatrix}=
            \begin{pmatrix}
                1&amp;  &amp;W_4^0  &amp;  \\
                &amp;1  &amp;  &amp;W_4^1  \\
                1&amp;  &amp;W_4^2  &amp;  \\
                &amp;1  &amp;  &amp;W_4^3 
            \end{pmatrix}\begin{pmatrix}
                A_1(0)\\A_1(1)\\A_2(0)\\A_2(1)
            \end{pmatrix}\]</span></p>
<p>And <span class="math display">\[\begin{pmatrix}
                A_1(0)\\A_1(1)\\A_2(0)\\A_2(1)
            \end{pmatrix}=\begin{pmatrix}
               1 &amp;  1&amp;  &amp;  \\
               1 &amp; -1 &amp;  &amp;  \\
                &amp;  &amp;1  &amp;1  \\
                &amp;  &amp; 1 &amp; -1
            \end{pmatrix}\begin{pmatrix}
                x(0)\\ x(2)\\x(1)\\x(3)
            \end{pmatrix}\]</span></p>
<h2 id="point-fft-1">8-point FFT</h2>
<p>To obtain 8-point FFT, we need to calculate two 4-point FFT first. <span class="math display">\[X^F(k)=B_0^F(k)+W_8^kB_1^F(k)\]</span> where <span class="math inline">\(B_0(k)=DFT\{x(0),x(2),x(4),x(6)\}(k)\)</span>,and <span class="math inline">\(B_1(k)=DFT\{x(1),x(3),x(5),x(7)\}\)</span></p>
<p>Write them in matrix form: <span class="math display">\[\begin{pmatrix}
            X^F(0)\\ X^F(1)\\X^F(2)\\X^F(3)\\X^F(4)\\X^F(5)\\X^F(6)\\X^F(7)
        \end{pmatrix}=
        \begin{pmatrix}
         1   &amp;  &amp;  &amp;  &amp;W_8^0  &amp;  &amp;  &amp;  \\
            &amp;1  &amp;  &amp;  &amp;  &amp;W_8^1  &amp;  &amp;  \\
            &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^2  &amp;  \\
            &amp;  &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^3  \\
         1   &amp;  &amp;  &amp;  &amp;W_8^4  &amp;  &amp;  &amp;  \\
            &amp;1  &amp;  &amp;  &amp;  &amp;W_8^5  &amp;  &amp;  \\
            &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^6  &amp;  \\
            &amp;  &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^7 
        \end{pmatrix}\begin{pmatrix}
            B_0(0)\\ B_0(1)\\ B_0(2)\\ B_0(3)\\B_1(0)\\B_1(1)\\B_1(2)\\B_1(3)
        \end{pmatrix}\]</span> and <span class="math display">\[\begin{pmatrix}
            B_0(0)\\ B_0(1)\\ B_0(2)\\ B_0(3)
        \end{pmatrix}=
        \begin{pmatrix}
            1&amp;  &amp;W_4^0  &amp;  \\
            &amp;1  &amp;  &amp;W_4^1  \\
            1&amp;  &amp;W_4^2  &amp;  \\
            &amp;1  &amp;  &amp;W_4^3 
        \end{pmatrix}
        \begin{pmatrix}
            A_0(0)\\A_0(1)\\A_1(0)\\A_1(1)
        \end{pmatrix}\]</span> where <span class="math display">\[\begin{pmatrix}
            A_0(0)\\A_0(1)
        \end{pmatrix}=\begin{pmatrix}
            1&amp;1\\
            1&amp;-1\\
        \end{pmatrix}\begin{pmatrix}
            x(0)\\x(4)
        \end{pmatrix}\quad
        \begin{pmatrix}
            A_1(0)\\A_1(1)
        \end{pmatrix}=\begin{pmatrix}
            1&amp;1\\
            1&amp;-1\\
        \end{pmatrix}\begin{pmatrix}
            x(2)\\x(6)
        \end{pmatrix}\]</span></p>
<p>Let's work them together: <span class="math display">\[\begin{aligned}
        \begin{pmatrix}
            X^F(0)\\ X^F(1)\\X^F(2)\\X^F(3)\\X^F(4)\\X^F(5)\\X^F(6)\\X^F(7)
        \end{pmatrix}&amp;=
        \begin{pmatrix}
            1   &amp;  &amp;  &amp;  &amp;W_8^0  &amp;  &amp;  &amp;  \\
            &amp;1  &amp;  &amp;  &amp;  &amp;W_8^1  &amp;  &amp;  \\
            &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^2  &amp;  \\
            &amp;  &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^3  \\
         1   &amp;  &amp;  &amp;  &amp;W_8^4  &amp;  &amp;  &amp;  \\
            &amp;1  &amp;  &amp;  &amp;  &amp;W_8^5  &amp;  &amp;  \\
            &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^6  &amp;  \\
            &amp;  &amp;  &amp;1  &amp;  &amp;  &amp;  &amp;W_8^7 
        \end{pmatrix}
        \begin{pmatrix}
            1&amp;  &amp;W_4^0  &amp;  &amp;&amp;&amp;&amp;\\
            &amp;1  &amp;  &amp;W_4^1  &amp;&amp;&amp;&amp;\\
            1&amp;  &amp;W_4^2  &amp;  &amp;&amp;&amp;&amp;\\
            &amp;1  &amp;  &amp;W_4^3 &amp;&amp;&amp;&amp;\\
            &amp;&amp;&amp;&amp;1&amp;  &amp;W_4^0  &amp;  \\
            &amp;&amp;&amp;&amp;&amp;1  &amp;  &amp;W_4^1  \\
            &amp;&amp;&amp;&amp;1&amp;  &amp;W_4^2  &amp;  \\
            &amp;&amp;&amp;&amp;&amp;1  &amp;  &amp;W_4^3 
        \end{pmatrix} \\
        &amp;\times\begin{pmatrix}
            1&amp;  1&amp;  &amp;  &amp;  &amp;  &amp;  &amp;  \\
            1&amp;  -1&amp;  &amp;  &amp;  &amp;  &amp;  &amp;  \\
            &amp;  &amp;  1&amp;  1&amp;  &amp;  &amp;  &amp;  \\
            &amp;  &amp;  1&amp;  -1&amp;  &amp;  &amp;  &amp;  \\
            &amp;  &amp;  &amp;  &amp;  1&amp;  1&amp;  &amp;  \\
            &amp;  &amp;  &amp;  &amp;  1&amp;  -1&amp;  &amp;  \\
            &amp;  &amp;  &amp;  &amp;  &amp;  &amp;1  &amp;1  \\
            &amp;  &amp;  &amp;  &amp;  &amp;  &amp;1  &amp;-1 
        \end{pmatrix}
        \begin{pmatrix}
            x(0)\\x(4)\\x(2)\\x(6)\\x(1)\\x(5)\\x(3)\\x(7)
        \end{pmatrix}  
    \end{aligned}\]</span></p>
<h1 id="algorithm">Algorithm</h1>
<p>To make the problem simple, we only study <span class="math inline">\(N=2^t\)</span>-point FFT.</p>
<h2 id="recursive-method">Recursive method</h2>
<p>Assume we are studying <span class="math inline">\(N=2^t\)</span>-point problem, and its correspond FFT algorithm is note as FFT[t]()</p>
<ol type="1">
<li><p>Input x[n] (A complex array of <span class="math inline">\(2^t\)</span> numbers)</p></li>
<li><p>Output <span class="math inline">\(X^F\)</span>[k] (Complex array with <span class="math inline">\(2^t\)</span> numbers)</p></li>
<li><p>Required parameter: <span class="math inline">\(t=log_2 N\)</span></p></li>
</ol>
<p>Our first step is to divide the input data into two array. Create two complex array a[r] and b[r] which have <span class="math inline">\(2^{t-1}\)</span> data respectively. Here is pseudo code.</p>
<pre><code>        for(r=0;r&lt;=N-1;r++){ /*N=2^t */ 
            a[r]=x[2*r];
            b[r]=x[2*r+1];
        }</code></pre>
<p>Then we apply the recursive method calculate the DFT of a[n] and b[n]. <span class="math display">\[\begin{split}
            &amp;a^F(k)=FFT[t-1](a)(k)\\
            &amp;b^F(k)=FFT[t-1](b)(k)\quad k=0,1,\cdots,2^{t-1}-1
        \end{split}\]</span> Here FFT[t-1] refers to the FFT algorithm that compute the DFT of the array with <span class="math inline">\(2^{t-1}\)</span> complex numbers. And here is pseudo code.</p>
<pre><code>        a_F=FFT[t-1](a);
        b_F=FFT[t-1](b);</code></pre>
<p>where a[n] and b[n] are two arrays with <span class="math inline">\(\frac{N}{2}=2^{t-1}\)</span> complex numbers ,and a_F[k] and b_F[k] are the DFT of a[n] and b[n] respectively.</p>
<p>However a_F[k] and b_F[k] are only defined for <span class="math inline">\(k\leq 2^{t-1}-1\)</span>. We can expand them periodically, <span class="math display">\[\begin{split}
            &amp;a^F(2^{t-1}+k)=a^F(k)\\
            &amp;b^F(2^{t-1}+k)=b^F(k)\quad k=0,1,\cdots,2^{t-1}-1
        \end{split}\]</span></p>
<p>As we have showed in the previous chapter: <span class="math display">\[X^F(k)=a^F(k)+W_{2^t}^kb^F(k)\]</span></p>
<p>The pseudo code is</p>
<pre><code>        for(k=0;k&lt;=N-1;k++){
            X_F[k]=a_F[k]+W^k*b_F[k]; /*W= exp(-2*pi*j/N) */
        }</code></pre>
<p>The computation has finished</p>
<h2 id="a-trick-to-improve-the-efficiency">A trick to improve the efficiency</h2>
<p>We find that to calculate <span class="math inline">\(W_{2^t}^k\)</span> may take lots of computation. Actually, we can only compute once, and store them in a complex array.</p>
<ol type="1">
<li><p>Create an array <span class="math inline">\(W_N[k]=\exp[\frac{-2\pi j}{N}\cdot k]\)</span> where <span class="math inline">\(N=2^{t_0}\)</span></p></li>
<li><p>Define a function <span class="math inline">\(W(t,k)=\exp[\frac{-2\pi j \cdot k}{2^t}]=\exp[\frac{-2\pi j \cdot k}{2^{t_0}}\cdot 2^{t_0 -t}]=W_N[k\cdot 2^{t_0-t}]\)</span></p></li>
</ol>
<h2 id="analyze-computation-complexity">Analyze computation complexity</h2>
<p>First of all, the complexity of <span class="math inline">\(2^t\)</span>-point FFT is C(t). In each FFT[t], we need to calculate two FFT[t-1] to obtain <span class="math inline">\(A^F[k]\)</span> and <span class="math inline">\(B^[k]\)</span>, then by <span class="math display">\[X^F(k)=A^F(k)+W_N^k B^F(k)\]</span> there will be <span class="math inline">\(2^t\)</span> complex multiplication and <span class="math inline">\(2^t\)</span> complex addition. To simplify, we note the complexity as <span class="math inline">\(2\cdot 2^t\)</span>.</p>
<p>Therefore: <span class="math display">\[C(t)=2\cdot C(t-1) + 2\cdot 2^t\]</span></p>
<p>Our goal is to calculate <span class="math inline">\(C(t)\)</span>.</p>
<p>To begin with, it is easy to evaluate that <span class="math inline">\(C[1]=4\)</span>. And, we divide <span class="math inline">\(2^t\)</span> on each side of the equation above. <span class="math display">\[\frac{C(t)}{2^t}=\frac{C(t-1)}{2^{t-1}}+2\]</span> Note <span class="math inline">\(b(t)=\frac{C(t)}{2^t}\)</span>, and <span class="math inline">\(b(1)=\frac{C(1)}{2}=2\)</span>. Therefore, <span class="math display">\[b(t)=b(t-1)+2\]</span></p>
<p>And it is easy to calculate <span class="math inline">\(b(t)\)</span> <span class="math display">\[b(t)=2t\]</span> Therefore, <span class="math display">\[C(t)=b(t)*2^t=2t\cdot 2^t\]</span> Note that <span class="math inline">\(N=2^t\)</span>, so <span class="math inline">\(t=log_2 N\)</span>, so <span class="math display">\[C(t)=2N\log_2N\]</span></p>
<h1 id="iteration-method">Iteration method</h1>
<h2 id="algorithm-introduction">Algorithm introduction</h2>
<p>Although recursive method is easy to understand, there are many disadvantages of recursive method. For example, we cannot free the memory; we cannot apply parallel computation. Therefore, we will introduce another equivalent method: iteration method.</p>
<p>The main difference is that we can calculate from bottom to top. For example, in the case of 8-p FFT, we firstly calculate 4 2-p FFT; then compute 2 4-p FFT; last, finish the computation.</p>
<p>Our procedure is : <span class="math display">\[\begin{pmatrix}
            x(0)\\x(1)\\x(2)\\x(3)\\x(4)\\x(5)\\x(6)\\x(7)
        \end{pmatrix}\longrightarrow
        \begin{pmatrix}
            x(0)\\x(4)\\x(2)\\x(6)\\x(1)\\x(5)\\x(3)\\x(7)
        \end{pmatrix}\longrightarrow
        \begin{pmatrix}
            A_0(0)\\A_0(1)\\A_1(0)\\A_1(1)\\A_2(0)\\A_2(1)\\A_3(0)\\A_3(1)
        \end{pmatrix}\longrightarrow
        \begin{pmatrix}
            B_0(0)\\B_0(1)\\B_0(2)\\B_0(3)\\B_1(0)\\B_1(1)\\B_1(2)\\B_1(3)
        \end{pmatrix}\longrightarrow
        \begin{pmatrix}
            X^F(0)\\X^F(1)\\X^F(2)\\X^F(3)\\X^F(4)\\X^F(5)\\X^F(6)\\X^F(7)
        \end{pmatrix}\]</span> Here</p>
<ol type="1">
<li><p><span class="math inline">\(B_0=DFT\{x(0),x(2),x(4),x(6)\}\)</span></p></li>
<li><p><span class="math inline">\(B_1=DFT\{x(1),x(3),x(5),x(7)\}\)</span></p></li>
<li><p><span class="math inline">\(A_0=DFT\{x(0),x(4)\}\)</span></p></li>
<li><p><span class="math inline">\(A_1=DFT\{x(2),x(6)\}\)</span></p></li>
<li><p><span class="math inline">\(A_2=DFT\{x(1),x(5)\}\)</span></p></li>
<li><p><span class="math inline">\(A_3=DFT\{x(3),x(7)\}\)</span></p></li>
</ol>
<h2 id="data-rearrangement">Data rearrangement</h2>
<p>As is shown above, a difficult part is to rearrange data. We need to change index {0,1,2,3,4,5,6,7} to {0,4,2,6,1,5,3,7}. Here I will only introduce an experience formula, I will write it in pseudo code. Assume <span class="math inline">\(2^t=N\)</span></p>
<pre><code>        int index[2^t];
        index[0]=0;
        for(i=0;i&lt;=t-1;i++){
            for(l=0;l&lt;=2^i-1;i++){
                index[2^i+l]=index[l]+2^(t-1-i)
            }
        }</code></pre>
<p>The new data array will be X_new[n]=x[index[n]]</p>
<p>Let's check this in the case of <span class="math inline">\(N=2^3\)</span></p>
<pre><code>        index[0]=0

        i=0
        l=0: index[1]=index[2^0+0]=index[0]+2^(3-1-0)=4
        
        i=1
        l=0: index[2]=index[2^1+0]=index[0]+2^(3-1-1)=2
        l=1: index[3]=index[2^1+1]=index[1]+2^(3-1-1)=6

        i=2
        l=0: index[4]=index[2^2+0]=index[0]+2^(3-1-2)=1
        l=1: index[5]=index[2^2+1]=index[1]+2^(3-1-2)=5
        l=2: index[6]=index[2^2+2]=index[2]+2^(3-1-2)=3
        l=3: index[7]=index[2^2+3]=index[3]+2^(3-1-2)=7</code></pre>
<h2 id="main-program">Main program</h2>
<p>Now let's finish our main program, I will show this in C language:</p>
<p>Define the function, with input complex xin[ ] and complex xout[ ]. "x" is the pointer of input data, "xf" is the pointer of an array that store the output.</p>
<pre><code>        void FFT(complex* xin,complex* xout)</code></pre>
<p>Assume the input data is an array with <span class="math inline">\(N=2^t\)</span> numbers, otherwise return error.</p>
<pre><code>        N=sizeof(x)/sizeof(x[0]);
        /* Assume that we have define a function to calculate the logarithm.*/
        t=log2(N);</code></pre>
<p>Then let's calculate the <span class="math display">\[W_N[k]=\exp(\frac{-2\pi j \cdot k}{N})\]</span> Then define a function</p>
<pre><code>        complex W(int i,int k){
            return W_N[k*2^i]
        }</code></pre>
<p>Then we continue to the key algorithm：</p>
<pre><code>        complex x[t+1][N]</code></pre>
<p>x[i] is an array to store the variable of each circle of calculation. For example: <span class="math display">\[x[0]=\begin{pmatrix}
            x(0)\\x(4)\\x(2)\\x(6)\\x(1)\\x(5)\\x(3)\\x(7)
        \end{pmatrix}\quad
        x[1]=\begin{pmatrix}
            A_0(0)\\A_0(1)\\A_1(0)\\A_1(1)\\A_2(0)\\A_2(1)\\A_3(0)\\A_3(1)
        \end{pmatrix}\quad
        x[2]=\begin{pmatrix}
            B_0(0)\\B_0(1)\\B_0(2)\\B_0(3)\\B_1(0)\\B_1(1)\\B_1(2)\\B_1(3)
        \end{pmatrix}\quad
        x[3]=\begin{pmatrix}
            X^F(0)\\X^F(1)\\X^F(2)\\X^F(3)\\X^F(4)\\X^F(5)\\X^F(6)\\X^F(7)
        \end{pmatrix}\]</span> In the real computation, when we calculate x[n+1], we can free the memory of x[n-1].</p>
<p>The main loop:</p>
<pre><code>    for(i=1;i&lt;=t;i++){
        for(j=0;j&lt;=(2^(t-i)-1);j++){
            for(l=0;l&lt;=2^(i-1);l++){
                x[i][j*2^i+l]=x[i-1][j*2^i+l mod 2^(i-1)]
                +W(i,l)x[i-1][j*2^(i-1)+l mod 2^(i-1)]
                }
            }
        }</code></pre>
<h2 id="explain">Explain</h2>
<p>Let's explain this pseudo code in a detailed way. Assume <span class="math inline">\(N=8,t=\log_2 8=3\)</span><br />
In the case of i=2, we want to calculate the x[2]. Let's explain the loop:</p>
<pre><code>    for(j=0;j&lt;=(2^(t-i)-1);j++)</code></pre>
<p>In this case t=3,i=2, so it becomes</p>
<pre><code>    for(j=0;j&lt;=1;j++)</code></pre>
<p>As we can see, <span class="math display">\[x[2]=\begin{pmatrix}
        B_0(0)\\B_0(1)\\B_0(2)\\B_0(3)\\B_1(0)\\B_1(1)\\B_1(2)\\B_1(3)
    \end{pmatrix}\]</span> For case j=0, refers that <span class="math inline">\(B_0\)</span> is stored in <span class="math inline">\(\{x[2][0],x[2][1],x[2][2],x[2][3]\}\)</span> and <span class="math inline">\(B_1\)</span> is stored in {x[2][4],x[2][5],x[2][6],x[2][7]}, which can also be expressed in <span class="math inline">\(\{x[2][0+2^i],x[2][1+2^i],x[2][2+2^i],x[2][3+2^i]\}\)</span>, here i=2</p>
<p>As we have proved <span class="math display">\[B_0[k]=A_0[k]+W_4^k A_1[k]\]</span> <span class="math inline">\(A_i[k]\)</span> can be expanded in this way <span class="math display">\[A_i[k+2^1]=A_i[k]\]</span> This can be achieved by</p>
<pre><code>    for(k=0;k&lt;=3,k++){
        A[k]=A[k mod 2]
    }</code></pre>
<p>Let's view this process again;</p>
<pre><code>    i=1, j=0,1,2,3
    In case j=0, we calculate A0; j=1 A1;j=2 A2; j=3 A3

    i=2 ,j=0,1;
    j=0, we calculate B0;
    j=1, we calculate B1;

    i=3, j=0
    We calculate XF.

    And x[3] is the final result, output it.

    for(i=0;i&lt;=2^t-1;i++){
        xout[i]=x[3][i];
    }</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/FFT/" rel="tag"># FFT</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/11/06/2-half-spin-particle-system-tensor-product-approach/" rel="prev" title="two half-spin-particle system_tensor product approach">
      <i class="fa fa-chevron-left"></i> two half-spin-particle system_tensor product approach
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/12/15/Dirac-equation-A-tensor-product-approach/" rel="next" title="Dirac equation_A tensor product approach">
      Dirac equation_A tensor product approach <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#discrete-fourier-transformation"><span class="nav-number">2.</span> <span class="nav-text">Discrete Fourier Transformation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#main-algorithm"><span class="nav-number">3.</span> <span class="nav-text">Main algorithm</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#detailed-examples"><span class="nav-number">4.</span> <span class="nav-text">Detailed examples</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#point-dft"><span class="nav-number">4.1.</span> <span class="nav-text">2-point DFT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#point-fft"><span class="nav-number">4.2.</span> <span class="nav-text">4-point FFT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#point-fft-1"><span class="nav-number">4.3.</span> <span class="nav-text">8-point FFT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#algorithm"><span class="nav-number">5.</span> <span class="nav-text">Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#recursive-method"><span class="nav-number">5.1.</span> <span class="nav-text">Recursive method</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-trick-to-improve-the-efficiency"><span class="nav-number">5.2.</span> <span class="nav-text">A trick to improve the efficiency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#analyze-computation-complexity"><span class="nav-number">5.3.</span> <span class="nav-text">Analyze computation complexity</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#iteration-method"><span class="nav-number">6.</span> <span class="nav-text">Iteration method</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#algorithm-introduction"><span class="nav-number">6.1.</span> <span class="nav-text">Algorithm introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#data-rearrangement"><span class="nav-number">6.2.</span> <span class="nav-text">Data rearrangement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main-program"><span class="nav-number">6.3.</span> <span class="nav-text">Main program</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explain"><span class="nav-number">6.4.</span> <span class="nav-text">Explain</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuhan Wu"
      src="https://raw.githubusercontent.com/YuhanWu314/Picture/main/touxiang.gif">
  <p class="site-author-name" itemprop="name">Yuhan Wu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuhan Wu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/blog/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
